# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1juCVJ8bIctVD3sEM4JOAbyeSgjgIrCtv
"""

def shortest_path(maze, start, end):
    rows = len(maze)
    cols = len(maze[0])

    visited = [[False] * cols for _ in range(rows)]
    distances = [[float('inf')] * cols for _ in range(rows)]
    parents = [[None] * cols for _ in range(rows)]

    bfs(maze, start, end, visited, distances, parents)

    path = reconstruct_path(start, end, parents)
    mark_path(maze, path)

    return maze

def bfs(maze, start, end, visited, distances, parents):
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    queue = []
    queue.append(start)
    visited[start[0]][start[1]] = True
    distances[start[0]][start[1]] = 0

    while queue:
        current_row, current_col = queue.pop(0)
        if (current_row, current_col) == end:
            break

        for direction in directions:
            new_row = current_row + direction[0]
            new_col = current_col + direction[1]

            if 0 <= new_row < len(maze) and 0 <= new_col < len(maze[0]):
                if maze[new_row][new_col] == 0 and not visited[new_row][new_col]:
                    visited[new_row][new_col] = True
                    queue.append((new_row, new_col))
                    distances[new_row][new_col] = distances[current_row][current_col] + 1
                    parents[new_row][new_col] = (current_row, current_col)

def reconstruct_path(start, end, parents):
    path = []
    current_pos = end
    while current_pos != start:
        path.append(current_pos)
        current_pos = parents[current_pos[0]][current_pos[1]]
    path.append(start)
    path.reverse()

    return path

def mark_path(maze, path):
    for pos in path:
        maze[pos[0]][pos[1]] = '*'

def print_maze_with_path(maze):
    for row in maze:
        row_str = ' '.join(['*' if cell == '*' else str(cell) for cell in row])
        print(f"[{row_str}]")

maze = [
    [0, 0, 1, 0, 0],
    [0, 0, 0, 0, 1],
    [0, 1, 0, 1, 0],
    [0, 1, 0, 0, 0],
    [0, 0, 0, 1, 0]
]
start = (0, 0)
end = (4, 4)

maze_with_path = shortest_path(maze, start, end)
print_maze_with_path(maze_with_path)